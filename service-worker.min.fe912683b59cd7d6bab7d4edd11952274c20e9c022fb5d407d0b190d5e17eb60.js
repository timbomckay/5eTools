(()=>{var O=["/5eTools/index.min.561301f5be519645c97938192171cdbf23e4742896df7158420659d268ec1a47.js","/5eTools/index.min.c2ec4dd825c89b28f43da223f4b57ce0fd9e1e8e3f364a8d3742628dde12cef6.css"],a,aT,aM,aL,b,aJ,aI,aH,ax,au,at,c,s,e,q,am,k,h,ad,d,F,X,o,j,W,R,l,Q,P,v,m,S,T,U,V,J,ai,E,D,H,y,N,w,z,x,r,aq,ar,u,av,i,K,ay,az,aA,aB,aD,aE,aF,g,aK,p,M,aP,t,aw;"use strict";try{self["workbox:core:6.4.1"]&&_()}catch(a){}a=(()=>{"__WB_DISABLE_DEV_LOGS"in self||(self.__WB_DISABLE_DEV_LOGS=!1);let a=!1;const b={debug:`#7f8c8d`,log:`#2ecc71`,warn:`#f39c12`,error:`#c0392b`,groupCollapsed:`#3498db`,groupEnd:null},d=function(c,d){if(self.__WB_DISABLE_DEV_LOGS)return;if(c==="groupCollapsed")if(/^((?!chrome|android).)*safari/i.test(navigator.userAgent)){console[c](...d);return}const e=[`background: ${b[c]}`,`border-radius: 0.5em`,`color: white`,`font-weight: bold`,`padding: 2px 0.5em`],f=a?[]:["%cworkbox",e.join(";")];console[c](...f,...d),c==="groupCollapsed"&&(a=!0),c==="groupEnd"&&(a=!1)},c={},e=Object.keys(b);for(const b of e){const a=b;c[a]=(...b)=>{d(a,b)}}return c})(),aT={"invalid-value":({paramName:a,validValueDescription:b,value:c})=>{if(!a||!b)throw new Error(`Unexpected input to 'invalid-value' error.`);return`The '${a}' parameter was given a value with an unexpected value. ${b} Received a value of ${JSON.stringify(c)}.`},"not-an-array":({moduleName:a,className:b,funcName:c,paramName:d})=>{if(!a||!b||!c||!d)throw new Error(`Unexpected input to 'not-an-array' error.`);return`The parameter '${d}' passed into '${a}.${b}.${c}()' must be an array.`},"incorrect-type":({expectedType:a,paramName:b,moduleName:c,className:d,funcName:e})=>{if(!a||!b||!c||!e)throw new Error(`Unexpected input to 'incorrect-type' error.`);const f=d?`${d}.`:"";return`The parameter '${b}' passed into '${c}.${f}${e}()' must be of type ${a}.`},"incorrect-class":({expectedClassName:a,paramName:f,moduleName:b,className:d,funcName:c,isReturnValueProblem:g})=>{if(!a||!b||!c)throw new Error(`Unexpected input to 'incorrect-class' error.`);const e=d?`${d}.`:"";return g?`The return value from '${b}.${e}${c}()' must be an instance of class ${a}.`:`The parameter '${f}' passed into '${b}.${e}${c}()' must be an instance of class ${a}.`},"missing-a-method":({expectedMethod:a,paramName:b,moduleName:c,className:d,funcName:e})=>{if(!a||!b||!c||!d||!e)throw new Error(`Unexpected input to 'missing-a-method' error.`);return`${c}.${d}.${e}() expected the '${b}' parameter to expose a '${a}' method.`},"add-to-cache-list-unexpected-type":({entry:a})=>`An unexpected entry was passed to 'workbox-precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(a)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`,"add-to-cache-list-conflicting-entries":({firstEntry:a,secondEntry:b})=>{if(!a||!b)throw new Error(`Unexpected input to 'add-to-cache-list-duplicate-entries' error.`);return`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${a} but different revision details. Workbox is unable to cache and version the asset correctly. Please remove one of the entries.`},"plugin-error-request-will-fetch":({thrownErrorMessage:a})=>{if(!a)throw new Error(`Unexpected input to 'plugin-error-request-will-fetch', error.`);return`An error was thrown by a plugins 'requestWillFetch()' method. The thrown error message was: '${a}'.`},"invalid-cache-name":({cacheNameId:a,value:b})=>{if(!a)throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);return`You must provide a name containing at least one character for setCacheDetails({${a}: '...'}). Received a value of '${JSON.stringify(b)}'`},"unregister-route-but-not-found-with-method":({method:a})=>{if(!a)throw new Error(`Unexpected input to 'unregister-route-but-not-found-with-method' error.`);return`The route you're trying to unregister was not  previously registered for the method type '${a}'.`},"unregister-route-route-not-registered":()=>`The route you're trying to unregister was not previously registered.`,"queue-replay-failed":({name:a})=>`Replaying the background sync queue '${a}' failed.`,"duplicate-queue-name":({name:a})=>`The Queue name '${a}' is already being used. All instances of backgroundSync.Queue must be given unique names.`,"expired-test-without-max-age":({methodName:a,paramName:b})=>`The '${a}()' method can only be used when the '${b}' is used in the constructor.`,"unsupported-route-type":({moduleName:a,className:b,funcName:c,paramName:d})=>`The supplied '${d}' parameter was an unsupported type. Please check the docs for ${a}.${b}.${c} for valid input types.`,"not-array-of-class":({value:a,expectedClass:b,moduleName:c,className:d,funcName:e,paramName:f})=>`The supplied '${f}' parameter must be an array of '${b}' objects. Received '${JSON.stringify(a)},'. Please check the call to ${c}.${d}.${e}() to fix the issue.`,"max-entries-or-age-required":({moduleName:a,className:b,funcName:c})=>`You must define either config.maxEntries or config.maxAgeSecondsin ${a}.${b}.${c}`,"statuses-or-headers-required":({moduleName:a,className:b,funcName:c})=>`You must define either config.statuses or config.headersin ${a}.${b}.${c}`,"invalid-string":({moduleName:a,funcName:b,paramName:c})=>{if(!c||!a||!b)throw new Error(`Unexpected input to 'invalid-string' error.`);return`When using strings, the '${c}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${a}.${b}() for more info.`},"channel-name-required":()=>`You must provide a channelName to construct a BroadcastCacheUpdate instance.`,"invalid-responses-are-same-args":()=>`The arguments passed into responsesAreSame() appear to be invalid. Please ensure valid Responses are used.`,"expire-custom-caches-only":()=>`You must provide a 'cacheName' property when using the expiration plugin with a runtime caching strategy.`,"unit-must-be-bytes":({normalizedRangeHeader:a})=>{if(!a)throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);return`The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was "${a}"`},"single-range-only":({normalizedRangeHeader:a})=>{if(!a)throw new Error(`Unexpected input to 'single-range-only' error.`);return`Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was "${a}"`},"invalid-range-values":({normalizedRangeHeader:a})=>{if(!a)throw new Error(`Unexpected input to 'invalid-range-values' error.`);return`The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was "${a}"`},"no-range-header":()=>`No Range header was found in the Request provided.`,"range-not-satisfiable":({size:a,start:b,end:c})=>`The start (${b}) and end (${c}) values in the Range are not satisfiable by the cached response, which is ${a} bytes.`,"attempt-to-cache-non-get-request":({url:a,method:b})=>`Unable to cache '${a}' because it is a '${b}' request and only 'GET' requests can be cached.`,"cache-put-with-no-response":({url:a})=>`There was an attempt to cache '${a}' but the response was not defined.`,"no-response":({url:c,error:a})=>{let b=`The strategy could not generate a response for '${c}'.`;return a&&(b+=` The underlying error is ${a}.`),b},"bad-precaching-response":({url:b,status:a})=>`The precaching request for '${b}' failed`+(a?` with an HTTP status of ${a}.`:`.`),"non-precached-url":({url:a})=>`createHandlerBoundToURL('${a}') was called, but that URL is not precached. Please pass in a URL that is precached instead.`,"add-to-cache-list-conflicting-integrities":({url:a})=>`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${a} with different integrity values. Please remove one of them.`,"missing-precache-entry":({cacheName:a,url:b})=>`Unable to find a precached response in ${a} for ${b}.`,"cross-origin-copy-response":({origin:a})=>`workbox-core.copyResponse() can only be used with same-origin responses. It was passed a response with origin ${a}.`},aM=(a,c={})=>{const b=aT[a];if(!b)throw new Error(`Unable to find message for code '${a}'.`);return b(c)},aL=aM,b=class extends Error{constructor(a,b){const c=aL(a,b);super(c),this.name=a,this.details=b}},aJ=(a,c)=>{if(!Array.isArray(a))throw new b("not-an-array",c)},aI=(d,a,c)=>{const e=typeof d[a];if(e!=="function")throw c.expectedMethod=a,new b("missing-a-method",c)},aH=(d,a,c)=>{if(typeof d!==a)throw c.expectedType=a,new b("incorrect-type",c)},ax=(d,a,c)=>{if(!(d instanceof a))throw c.expectedClassName=a.name,new b("incorrect-class",c)},au=(d,a,c)=>{if(!a.includes(d))throw c.validValueDescription=`Valid values are ${JSON.stringify(a)}.`,new b("invalid-value",c)},at=(a,d,e)=>{const c=new b("not-array-of-class",e);if(!Array.isArray(a))throw c;for(const b of a)if(!(b instanceof d))throw c},c={hasMethod:aI,isArray:aJ,isInstance:ax,isOneOf:au,isType:aH,isArrayOfClass:at},s=new Set;function an(b){!0&&c.isType(b,"function",{moduleName:"workbox-core",funcName:"register",paramName:"callback"}),s.add(b),!0&&a.log("Registered a callback to respond to quota errors.",b)}e={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration!="undefined"?registration.scope:""},q=a=>[e.prefix,a,e.suffix].filter(a=>a&&a.length>0).join("-"),am=a=>{for(const b of Object.keys(e))a(b)},k={updateDetails:a=>{am(b=>{typeof a[b]=="string"&&(e[b]=a[b])})},getGoogleAnalyticsName:a=>a||q(e.googleAnalytics),getPrecacheName:a=>a||q(e.precache),getPrefix:()=>e.prefix,getRuntimeName:a=>a||q(e.runtime),getSuffix:()=>e.suffix};function B(b,c){const a=new URL(b);for(const b of c)a.searchParams.delete(b);return a.href}async function af(b,a,d,c){const e=B(a.url,d);if(a.url===e)return b.match(a,c);const f=Object.assign(Object.assign({},c),{ignoreSearch:!0}),g=await b.keys(a,f);for(const a of g){const f=B(a.url,d);if(e===f)return b.match(a,c)}}function ae(){if(h===void 0){const a=new Response("");if("body"in a)try{new Response(a.body),h=!0}catch(a){h=!1}h=!1}return h}function G(a){void a.then(()=>{})}ad=class{constructor(){this.promise=new Promise((a,b)=>{this.resolve=a,this.reject=b})}};async function ac(){!0&&a.log(`About to run ${s.size} callbacks to clean up caches.`);for(const b of s)await b(),!0&&a.log(b,"is complete.");!0&&a.log("Finished running callbacks.")}d=a=>{const b=new URL(String(a),location.href);return b.href.replace(new RegExp(`^${location.origin}`),"")};function ab(a){return new Promise(b=>setTimeout(b,a))}function C(b,c){const a=c();return b.waitUntil(a),a}async function Z(c,e){let d=null;if(c.url){const a=new URL(c.url);d=a.origin}if(d!==self.location.origin)throw new b("cross-origin-copy-response",{origin:d});const a=c.clone(),f={headers:new Headers(a.headers),status:a.status,statusText:a.statusText},g=e?e(f):f,h=ae()?a.body:await a.blob();return new Response(h,g)}function Y(a){if(!0){if(Object.keys(a).forEach(b=>{c.isType(a[b],"string",{moduleName:"workbox-core",funcName:"setCacheNameDetails",paramName:`details.${b}`})}),"precache"in a&&a.precache.length===0)throw new b("invalid-cache-name",{cacheNameId:"precache",value:a.precache});if("runtime"in a&&a.runtime.length===0)throw new b("invalid-cache-name",{cacheNameId:"runtime",value:a.runtime});if("googleAnalytics"in a&&a.googleAnalytics.length===0)throw new b("invalid-cache-name",{cacheNameId:"googleAnalytics",value:a.googleAnalytics})}k.updateDetails(a)}"use strict";try{self["workbox:routing:6.4.1"]&&_()}catch(a){}F="GET",X=["DELETE","GET","HEAD","PATCH","POST","PUT"],o=a=>a&&typeof a=="object"?(!0&&c.hasMethod(a,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),a):(!0&&c.isType(a,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),{handle:a}),j=class{constructor(b,d,a=F){!0&&(c.isType(b,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"}),a&&c.isOneOf(a,X,{paramName:"method"})),this.handler=o(d),this.match=b,this.method=a}setCatchHandler(a){this.catchHandler=o(a)}},W=class extends j{constructor(b,d,e){!0&&c.isInstance(b,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"});const f=({url:c})=>{const d=b.exec(c.href);if(!d)return;if(c.origin!==location.origin&&d.index!==0){!0&&a.debug(`The regular expression '${b.toString()}' only partially matched against the cross-origin URL '${c.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`);return}return d.slice(1)};super(f,d,e)}},R=class{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",a=>{const{request:c}=a,b=this.handleRequest({request:c,event:a});b&&a.respondWith(b)})}addCacheListener(){self.addEventListener("message",b=>{if(b.data&&b.data.type==="CACHE_URLS"){const{payload:c}=b.data;!0&&a.debug(`Caching URLs from the window`,c.urlsToCache);const d=Promise.all(c.urlsToCache.map(a=>{typeof a=="string"&&(a=[a]);const c=new Request(...a);return this.handleRequest({request:c,event:b})}));b.waitUntil(d),b.ports&&b.ports[0]&&void d.then(()=>b.ports[0].postMessage(!0))}})}handleRequest({request:e,event:i}){!0&&c.isInstance(e,Request,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"options.request"});const b=new URL(e.url,location.href);if(!b.protocol.startsWith("http")){!0&&a.debug(`Workbox Router only supports URLs that start with 'http'.`);return}const n=b.origin===location.origin,{params:j,route:f}=this.findMatchingRoute({event:i,request:e,sameOrigin:n,url:b});let h=f&&f.handler;const k=[];!0&&h&&(k.push([`Found a route to handle this request:`,f]),j&&k.push([`Passing the following params to the route's handler:`,j]));const l=e.method;if(!h&&this._defaultHandlerMap.has(l)&&(!0&&k.push(`Failed to find a matching route. Falling back to the default handler for ${l}.`),h=this._defaultHandlerMap.get(l)),!h){!0&&a.debug(`No route found for: ${d(b)}`);return}!0&&(a.groupCollapsed(`Router is responding to: ${d(b)}`),k.forEach(b=>{Array.isArray(b)?a.log(...b):a.log(b)}),a.groupEnd());let g;try{g=h.handle({url:b,request:e,event:i,params:j})}catch(a){g=Promise.reject(a)}const m=f&&f.catchHandler;return g instanceof Promise&&(this._catchHandler||m)&&(g=g.catch(async c=>{if(m){!0&&(a.groupCollapsed(`Error thrown when responding to:  ${d(b)}. Falling back to route's Catch Handler.`),a.error(`Error thrown by:`,f),a.error(c),a.groupEnd());try{return await m.handle({url:b,request:e,event:i,params:j})}catch(a){a instanceof Error&&(c=a)}}if(this._catchHandler)return!0&&(a.groupCollapsed(`Error thrown when responding to:  ${d(b)}. Falling back to global Catch Handler.`),a.error(`Error thrown by:`,f),a.error(c),a.groupEnd()),this._catchHandler.handle({url:b,request:e,event:i});throw c})),g}findMatchingRoute({url:b,sameOrigin:e,request:c,event:f}){const g=this._routes.get(c.method)||[];for(const j of g){let h;const i=j.match({url:b,sameOrigin:e,request:c,event:f});if(i)return!0&&i instanceof Promise&&a.warn(`While routing ${d(b)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`,j),h=i,Array.isArray(h)&&h.length===0?h=void 0:i.constructor===Object&&Object.keys(i).length===0?h=void 0:typeof i=="boolean"&&(h=void 0),{route:j,params:h}}return{}}setDefaultHandler(a,b=F){this._defaultHandlerMap.set(b,o(a))}setCatchHandler(a){this._catchHandler=o(a)}registerRoute(a){!0&&(c.isType(a,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),c.hasMethod(a,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),c.isType(a.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),c.hasMethod(a.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"}),c.isType(a.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"})),this._routes.has(a.method)||this._routes.set(a.method,[]),this._routes.get(a.method).push(a)}unregisterRoute(a){if(!this._routes.has(a.method))throw new b("unregister-route-but-not-found-with-method",{method:a.method});const c=this._routes.get(a.method).indexOf(a);if(c>-1)this._routes.get(a.method).splice(c,1);else throw new b("unregister-route-route-not-registered")}},Q=()=>(l||(l=new R,l.addFetchListener(),l.addCacheListener()),l);function A(c,e,f){let d;if(typeof c=="string"){const g=new URL(c,location.href);if(!0){if(!(c.startsWith("/")||c.startsWith("http")))throw new b("invalid-string",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});const e=c.startsWith("http")?g.pathname:c,d="[*:?+]";new RegExp(`${d}`).exec(e)&&a.debug(`The '$capture' parameter contains an Express-style wildcard character (${d}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`)}const h=({url:b})=>(!0&&b.pathname===g.pathname&&b.origin!==g.origin&&a.debug(`${c} only partially matches the cross-origin URL ${b.toString()}. This route will only handle cross-origin requests if they match the entire URL.`),b.href===g.href);d=new j(h,e,f)}else if(c instanceof RegExp)d=new W(c,e,f);else if(typeof c=="function")d=new j(c,e,f);else if(c instanceof j)d=c;else throw new b("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});const g=Q();return g.registerRoute(d),d}"use strict";try{self["workbox:strategies:6.4.1"]&&_()}catch(a){}function n(a){return typeof a=="string"?new Request(a):a}P=class{constructor(b,a){this._cacheKeys={},!0&&c.isInstance(a.event,ExtendableEvent,{moduleName:"workbox-strategies",className:"StrategyHandler",funcName:"constructor",paramName:"options.event"}),Object.assign(this,a),this.event=a.event,this._strategy=b,this._handlerDeferred=new ad,this._extendLifetimePromises=[],this._plugins=[...b.plugins],this._pluginStateMap=new Map;for(const a of this._plugins)this._pluginStateMap.set(a,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(h){const{event:e}=this;let c=n(h);if(c.mode==="navigate"&&e instanceof FetchEvent&&e.preloadResponse){const b=await e.preloadResponse;if(b)return!0&&a.log(`Using a preloaded navigation response for '${d(c.url)}'`),b}const f=this.hasCallback("fetchDidFail")?c.clone():null;try{for(const a of this.iterateCallbacks("requestWillFetch"))c=await a({request:c.clone(),event:e})}catch(a){if(a instanceof Error)throw new b("plugin-error-request-will-fetch",{thrownErrorMessage:a.message})}const g=c.clone();try{let b;b=await fetch(c,c.mode==="navigate"?void 0:this._strategy.fetchOptions),!0&&a.debug(`Network request for '${d(c.url)}' returned a response with status '${b.status}'.`);for(const a of this.iterateCallbacks("fetchDidSucceed"))b=await a({event:e,request:g,response:b});return b}catch(b){throw!0&&a.log(`Network request for '${d(c.url)}' threw an error.`,b),f&&await this.runCallbacks("fetchDidFail",{error:b,event:e,originalRequest:f.clone(),request:g.clone()}),b}}async fetchAndCachePut(a){const b=await this.fetch(a),c=b.clone();return void this.waitUntil(this.cachePut(a,c)),b}async cacheMatch(f){const g=n(f);let b;const{cacheName:c,matchOptions:d}=this._strategy,e=await this.getCacheKey(g,"read"),h=Object.assign(Object.assign({},d),{cacheName:c});b=await caches.match(e,h),!0&&(b?a.debug(`Found a cached response in '${c}'.`):a.debug(`No cached response found in '${c}'.`));for(const a of this.iterateCallbacks("cachedResponseWillBeUsed"))b=await a({cacheName:c,matchOptions:d,cachedResponse:b,request:e,event:this.event})||void 0;return b}async cachePut(j,f){const l=n(j);await ab(0);const c=await this.getCacheKey(l,"write");if(!0){if(c.method&&c.method!=="GET")throw new b("attempt-to-cache-non-get-request",{url:d(c.url),method:c.method});const e=f.headers.get("Vary");e&&a.debug(`The response for ${d(c.url)} has a 'Vary: ${e}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`)}if(!f)throw!0&&a.error(`Cannot cache non-existent response for '${d(c.url)}'.`),new b("cache-put-with-no-response",{url:d(c.url)});const e=await this._ensureResponseSafeToCache(f);if(!e)return!0&&a.debug(`Response '${d(c.url)}' will not be cached.`,e),!1;const{cacheName:g,matchOptions:k}=this._strategy,i=await self.caches.open(g),h=this.hasCallback("cacheDidUpdate"),m=h?await af(i,c.clone(),["__WB_REVISION__"],k):null;!0&&a.debug(`Updating the '${g}' cache with a new Response for ${d(c.url)}.`);try{await i.put(c,h?e.clone():e)}catch(a){if(a instanceof Error)throw a.name==="QuotaExceededError"&&await ac(),a}for(const a of this.iterateCallbacks("cacheDidUpdate"))await a({cacheName:g,oldResponse:m,newResponse:e.clone(),request:c,event:this.event});return!0}async getCacheKey(b,c){const a=`${b.url} | ${c}`;if(!this._cacheKeys[a]){let d=b;for(const a of this.iterateCallbacks("cacheKeyWillBeUsed"))d=n(await a({mode:c,request:d,event:this.event,params:this.params}));this._cacheKeys[a]=d}return this._cacheKeys[a]}hasCallback(a){for(const b of this._strategy.plugins)if(a in b)return!0;return!1}async runCallbacks(a,b){for(const c of this.iterateCallbacks(a))await c(b)}*iterateCallbacks(a){for(const b of this._strategy.plugins)if(typeof b[a]=="function"){const c=this._pluginStateMap.get(b),d=d=>{const e=Object.assign(Object.assign({},d),{state:c});return b[a](e)};yield d}}waitUntil(a){return this._extendLifetimePromises.push(a),a}async doneWaiting(){let a;while(a=this._extendLifetimePromises.shift())await a}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(c){let b=c,d=!1;for(const a of this.iterateCallbacks("cacheWillUpdate"))if(b=await a({request:this.request,response:b,event:this.event})||void 0,d=!0,!b)break;return d||(b&&b.status!==200&&(b=void 0),!0&&b&&b.status!==200&&(b.status===0?a.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`):a.debug(`The response for '${this.request.url}' returned a status code of '${c.status}' and won't be cached as a result.`))),b}},v=class{constructor(a={}){this.cacheName=k.getRuntimeName(a.cacheName),this.plugins=a.plugins||[],this.fetchOptions=a.fetchOptions,this.matchOptions=a.matchOptions}handle(a){const[b]=this.handleAll(a);return b}handleAll(a){a instanceof FetchEvent&&(a={event:a,request:a.request});const b=a.event,c=typeof a.request=="string"?new Request(a.request):a.request,f="params"in a?a.params:void 0,d=new P(this,{event:b,request:c,params:f}),e=this._getResponse(d,c,b),g=this._awaitComplete(e,d,c,b);return[e,g]}async _getResponse(f,e,g){await f.runCallbacks("handlerWillStart",{event:g,request:e});let c=void 0;try{if(c=await this._handle(e,f),!c||c.type==="error")throw new b("no-response",{url:e.url})}catch(b){if(b instanceof Error)for(const a of f.iterateCallbacks("handlerDidError"))if(c=await a({error:b,event:g,request:e}),c)break;if(!c)throw b;!0&&a.log(`While responding to '${d(e.url)}', an ${b instanceof Error?b.toString():""} error occurred. Using a fallback response provided by a handlerDidError plugin.`)}for(const a of f.iterateCallbacks("handlerWillRespond"))c=await a({event:g,request:e,response:c});return c}async _awaitComplete(f,a,d,e){let c,b;try{c=await f}catch(a){}try{await a.runCallbacks("handlerDidRespond",{event:e,request:d,response:c}),await a.doneWaiting()}catch(a){a instanceof Error&&(b=a)}if(await a.runCallbacks("handlerDidComplete",{event:e,request:d,response:c,error:b}),a.destroy(),b)throw b}},m={strategyStart:(a,b)=>`Using ${a} to respond to '${d(b.url)}'`,printFinalResponse:b=>{b&&(a.groupCollapsed(`View the final response here.`),a.log(b||"[No response returned]"),a.groupEnd())}},S=class extends v{async _handle(e,g){const f=[];!0&&c.isInstance(e,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"makeRequest",paramName:"request"});let d=await g.cacheMatch(e),h=void 0;if(d)!0&&f.push(`Found a cached response in the '${this.cacheName}' cache.`);else{!0&&f.push(`No response found in the '${this.cacheName}' cache. Will respond with a network request.`);try{d=await g.fetchAndCachePut(e)}catch(a){a instanceof Error&&(h=a)}!0&&(d?f.push(`Got response from network.`):f.push(`Unable to get a response from the network.`))}if(!0){a.groupCollapsed(m.strategyStart(this.constructor.name,e));for(const b of f)a.log(b);m.printFinalResponse(d),a.groupEnd()}if(!d)throw new b("no-response",{url:e.url,error:h});return d}},T={cacheWillUpdate:async({response:a})=>a.status===200||a.status===0?a:null},U=class extends v{constructor(a={}){super(a),this.plugins.some(a=>"cacheWillUpdate"in a)||this.plugins.unshift(T),this._networkTimeoutSeconds=a.networkTimeoutSeconds||0,!0&&this._networkTimeoutSeconds&&c.isType(this._networkTimeoutSeconds,"number",{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"constructor",paramName:"networkTimeoutSeconds"})}async _handle(d,e){const f=[];!0&&c.isInstance(d,Request,{moduleName:"workbox-strategies",className:this.constructor.name,funcName:"handle",paramName:"makeRequest"});const g=[];let i;if(this._networkTimeoutSeconds){const{id:a,promise:b}=this._getTimeoutPromise({request:d,logs:f,handler:e});i=a,g.push(b)}const j=this._getNetworkPromise({timeoutId:i,request:d,logs:f,handler:e});g.push(j);const h=await e.waitUntil((async()=>await e.waitUntil(Promise.race(g))||await j)());if(!0){a.groupCollapsed(m.strategyStart(this.constructor.name,d));for(const b of f)a.log(b);m.printFinalResponse(h),a.groupEnd()}if(!h)throw new b("no-response",{url:d.url});return h}_getTimeoutPromise({request:b,logs:c,handler:d}){let a;const e=new Promise(e=>{const f=async()=>{!0&&c.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`),e(await d.cacheMatch(b))};a=setTimeout(f,this._networkTimeoutSeconds*1e3)});return{promise:e,id:a}}async _getNetworkPromise({timeoutId:c,request:d,logs:b,handler:e}){let f,a;try{a=await e.fetchAndCachePut(d)}catch(a){a instanceof Error&&(f=a)}return c&&clearTimeout(c),!0&&(a?b.push(`Got response from network.`):b.push(`Unable to get a response from the network. Will respond with a cached response.`)),(f||!a)&&(a=await e.cacheMatch(d),!0&&(a?b.push(`Found a cached response in the '${this.cacheName}' cache.`):b.push(`No response found in the '${this.cacheName}' cache.`))),a}};"use strict";try{self["workbox:cacheable-response:6.4.1"]&&_()}catch(a){}V=class{constructor(a={}){if(!0){if(!(a.statuses||a.headers))throw new b("statuses-or-headers-required",{moduleName:"workbox-cacheable-response",className:"CacheableResponse",funcName:"constructor"});a.statuses&&c.isArray(a.statuses,{moduleName:"workbox-cacheable-response",className:"CacheableResponse",funcName:"constructor",paramName:"config.statuses"}),a.headers&&c.isType(a.headers,"object",{moduleName:"workbox-cacheable-response",className:"CacheableResponse",funcName:"constructor",paramName:"config.headers"})}this._statuses=a.statuses,this._headers=a.headers}isResponseCacheable(b){!0&&c.isInstance(b,Response,{moduleName:"workbox-cacheable-response",className:"CacheableResponse",funcName:"isResponseCacheable",paramName:"response"});let e=!0;if(this._statuses&&(e=this._statuses.includes(b.status)),this._headers&&e&&(e=Object.keys(this._headers).some(a=>b.headers.get(a)===this._headers[a])),!0)if(!e){a.groupCollapsed(`The request for '${d(b.url)}' returned a response that does not meet the criteria for being cached.`),a.groupCollapsed(`View cacheability criteria here.`),a.log(`Cacheable statuses: `+JSON.stringify(this._statuses)),a.log(`Cacheable headers: `+JSON.stringify(this._headers,null,2)),a.groupEnd();const c={};b.headers.forEach((a,b)=>{c[b]=a}),a.groupCollapsed(`View response status and headers here.`),a.log(`Response status: ${b.status}`),a.log(`Response headers: `+JSON.stringify(c,null,2)),a.groupEnd(),a.groupCollapsed(`View full response details here.`),a.log(b.headers),a.log(b),a.groupEnd(),a.groupEnd()}return e}},J=class{constructor(a){this.cacheWillUpdate=async({response:a})=>this._cacheableResponse.isResponseCacheable(a)?a:null,this._cacheableResponse=new V(a)}},ai=(a,b)=>b.some(b=>a instanceof b);function $(){return E||(E=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function aa(){return D||(D=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}H=new WeakMap,y=new WeakMap,N=new WeakMap,w=new WeakMap,z=new WeakMap;function ag(a){const b=new Promise((e,g)=>{const b=()=>{a.removeEventListener("success",c),a.removeEventListener("error",d)},c=()=>{e(f(a.result)),b()},d=()=>{g(a.error),b()};a.addEventListener("success",c),a.addEventListener("error",d)});return b.then(b=>{b instanceof IDBCursor&&H.set(b,a)}).catch(()=>{}),z.set(b,a),b}function ah(a){if(y.has(a))return;const b=new Promise((e,f)=>{const c=()=>{a.removeEventListener("complete",d),a.removeEventListener("error",b),a.removeEventListener("abort",b)},d=()=>{e(),c()},b=()=>{f(a.error||new DOMException("AbortError","AbortError")),c()};a.addEventListener("complete",d),a.addEventListener("error",b),a.addEventListener("abort",b)});y.set(a,b)}x={get(a,b,c){if(a instanceof IDBTransaction){if(b==="done")return y.get(a);if(b==="objectStoreNames")return a.objectStoreNames||N.get(a);if(b==="store")return c.objectStoreNames[1]?void 0:c.objectStore(c.objectStoreNames[0])}return f(a[b])},set(a,b,c){return a[b]=c,!0},has(b,a){return!!(b instanceof IDBTransaction&&(a==="done"||a==="store"))||a in b}};function aj(a){x=a(x)}function ak(a){return a===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(b,...d){const c=a.call(r(this),b,...d);return N.set(c,b.sort?b.sort():[b]),f(c)}:aa().includes(a)?function(...b){return a.apply(r(this),b),f(H.get(this))}:function(...b){return f(a.apply(r(this),b))}}function al(a){return typeof a=="function"?ak(a):(a instanceof IDBTransaction&&ah(a),ai(a,$()))?new Proxy(a,x):a}function f(a){if(a instanceof IDBRequest)return ag(a);if(w.has(a))return w.get(a);const b=al(a);return b!==a&&(w.set(a,b),z.set(b,a)),b}r=a=>z.get(a);function ao(h,i,{blocked:c,upgrade:d,blocking:e,terminated:g}={}){const a=indexedDB.open(h,i),b=f(a);return d&&a.addEventListener("upgradeneeded",b=>{d(f(a.result),b.oldVersion,b.newVersion,f(a.transaction))}),c&&a.addEventListener("blocked",()=>c()),b.then(a=>{g&&a.addEventListener("close",()=>g()),e&&a.addEventListener("versionchange",()=>e())}).catch(()=>{}),b}function ap(c,{blocked:a}={}){const b=indexedDB.deleteDatabase(c);return a&&b.addEventListener("blocked",()=>a()),f(b).then(()=>{})}aq=["get","getKey","getAll","getAllKeys","count"],ar=["put","add","delete","clear"],u=new Map;function I(d,a){if(!(d instanceof IDBDatabase&&!(a in d)&&typeof a=="string"))return;if(u.get(a))return u.get(a);const b=a.replace(/FromIndex$/,""),e=a!==b,c=ar.includes(b);if(!(b in(e?IDBIndex:IDBObjectStore).prototype)||!(c||aq.includes(b)))return;const f=async function(g,...d){const f=this.transaction(g,c?"readwrite":"readonly");let a=f.store;return e&&(a=a.index(d.shift())),(await Promise.all([a[b](...d),c&&f.done]))[0]};return u.set(a,f),f}aj(a=>({...a,get:(b,c,d)=>I(b,c)||a.get(b,c,d),has:(b,c)=>!!I(b,c)||a.has(b,c)}));"use strict";try{self["workbox:expiration:6.4.1"]&&_()}catch(a){}av="workbox-expiration",i="cache-entries",K=b=>{const a=new URL(b,location.href);return a.hash="",a.href},ay=class{constructor(a){this._db=null,this._cacheName=a}_upgradeDb(b){const a=b.createObjectStore(i,{keyPath:"id"});a.createIndex("cacheName","cacheName",{unique:!1}),a.createIndex("timestamp","timestamp",{unique:!1})}_upgradeDbAndDeleteOldDbs(a){this._upgradeDb(a),this._cacheName&&void ap(this._cacheName)}async setTimestamp(a,c){a=K(a);const d={url:a,timestamp:c,cacheName:this._cacheName,id:this._getId(a)},e=await this.getDb(),b=e.transaction(i,"readwrite",{durability:"relaxed"});await b.store.put(d),await b.done}async getTimestamp(b){const c=await this.getDb(),a=await c.get(i,this._getId(b));return a===null||a===void 0?void 0:a.timestamp}async expireEntries(b,c){const d=await this.getDb();let a=await d.transaction(i).store.index("timestamp").openCursor(null,"prev");const e=[];let f=0;while(a){const d=a.value;d.cacheName===this._cacheName&&(b&&d.timestamp<b||c&&f>=c?e.push(a.value):f++),a=await a.continue()}const g=[];for(const a of e)await d.delete(i,a.id),g.push(a.url);return g}_getId(a){return this._cacheName+"|"+K(a)}async getDb(){return this._db||(this._db=await ao(av,1,{upgrade:this._upgradeDbAndDeleteOldDbs.bind(this)})),this._db}},az=class{constructor(d,a={}){if(this._isRunning=!1,this._rerunRequested=!1,!0){if(c.isType(d,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"cacheName"}),!(a.maxEntries||a.maxAgeSeconds))throw new b("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor"});a.maxEntries&&c.isType(a.maxEntries,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxEntries"}),a.maxAgeSeconds&&c.isType(a.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxAgeSeconds"})}this._maxEntries=a.maxEntries,this._maxAgeSeconds=a.maxAgeSeconds,this._matchOptions=a.matchOptions,this._cacheName=d,this._timestampModel=new ay(d)}async expireEntries(){if(this._isRunning){this._rerunRequested=!0;return}this._isRunning=!0;const c=this._maxAgeSeconds?Date.now()-this._maxAgeSeconds*1e3:0,b=await this._timestampModel.expireEntries(c,this._maxEntries),d=await self.caches.open(this._cacheName);for(const a of b)await d.delete(a,this._matchOptions);!0&&(b.length>0?(a.groupCollapsed(`Expired ${b.length} ${b.length===1?"entry":"entries"} and removed ${b.length===1?"it":"them"} from the '${this._cacheName}' cache.`),a.log(`Expired the following ${b.length===1?"URL":"URLs"}:`),b.forEach(b=>a.log(`    ${b}`)),a.groupEnd()):a.debug(`Cache expiration ran and found no entries to remove.`)),this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,G(this.expireEntries()))}async updateTimestamp(a){!0&&c.isType(a,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"updateTimestamp",paramName:"url"}),await this._timestampModel.setTimestamp(a,Date.now())}async isURLExpired(c){if(!this._maxAgeSeconds){if(!0)throw new b(`expired-test-without-max-age`,{methodName:"isURLExpired",paramName:"maxAgeSeconds"});return!1}const a=await this._timestampModel.getTimestamp(c),d=Date.now()-this._maxAgeSeconds*1e3;return a===void 0||a<d}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}},aA=class{constructor(e={}){if(this.cachedResponseWillBeUsed=async({event:b,request:f,cacheName:g,cachedResponse:c})=>{if(!c)return null;const h=this._isResponseDateFresh(c),e=this._getCacheExpiration(g);G(e.expireEntries());const i=e.updateTimestamp(f.url);if(b)try{b.waitUntil(i)}catch(c){!0&&"request"in b&&a.warn(`Unable to ensure service worker stays alive when updating cache entry for '${d(b.request.url)}'.`)}return h?c:null},this.cacheDidUpdate=async({cacheName:a,request:b})=>{!0&&(c.isType(a,"string",{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"cacheName"}),c.isInstance(b,Request,{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"request"}));const d=this._getCacheExpiration(a);await d.updateTimestamp(b.url),await d.expireEntries()},!0){if(!(e.maxEntries||e.maxAgeSeconds))throw new b("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor"});e.maxEntries&&c.isType(e.maxEntries,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxEntries"}),e.maxAgeSeconds&&c.isType(e.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxAgeSeconds"})}this._config=e,this._maxAgeSeconds=e.maxAgeSeconds,this._cacheExpirations=new Map,e.purgeOnQuotaError&&an(()=>this.deleteCacheAndMetadata())}_getCacheExpiration(a){if(a===k.getRuntimeName())throw new b("expire-custom-caches-only");let c=this._cacheExpirations.get(a);return c||(c=new az(a,this._config),this._cacheExpirations.set(a,c)),c}_isResponseDateFresh(b){if(!this._maxAgeSeconds)return!0;const a=this._getDateHeaderTimestamp(b);if(a===null)return!0;const c=Date.now();return a>=c-this._maxAgeSeconds*1e3}_getDateHeaderTimestamp(a){if(!a.headers.has("date"))return null;const c=a.headers.get("date"),d=new Date(c),b=d.getTime();return isNaN(b)?null:b}async deleteCacheAndMetadata(){for(const[a,b]of this._cacheExpirations)await self.caches.delete(a),await b.delete();this._cacheExpirations=new Map}},"use strict";try{self["workbox:precaching:6.4.1"]&&_()}catch(a){}aB="__WB_REVISION__";function aC(a){if(!a)throw new b("add-to-cache-list-unexpected-type",{entry:a});if(typeof a=="string"){const b=new URL(a,location.href);return{cacheKey:b.href,url:b.href}}const{revision:d,url:c}=a;if(!c)throw new b("add-to-cache-list-unexpected-type",{entry:a});if(!d){const a=new URL(c,location.href);return{cacheKey:a.href,url:a.href}}const e=new URL(c,location.href),f=new URL(c,location.href);return e.searchParams.set(aB,d),{cacheKey:e.href,url:f.href}}aD=class{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:b,state:a})=>{a&&(a.originalRequest=b)},this.cachedResponseWillBeUsed=async({event:c,state:a,cachedResponse:b})=>{if(c.type==="install")if(a&&a.originalRequest&&a.originalRequest instanceof Request){const c=a.originalRequest.url;b?this.notUpdatedURLs.push(c):this.updatedURLs.push(c)}return b}}},aE=class{constructor({precacheController:a}){this.cacheKeyWillBeUsed=async({request:a,params:b})=>{const c=(b===null||b===void 0?void 0:b.cacheKey)||this._precacheController.getCacheKeyForURL(a.url);return c?new Request(c,{headers:a.headers}):a},this._precacheController=a}},aF=(b,c)=>{a.groupCollapsed(b);for(const b of c)a.log(b);a.groupEnd()};function aG(c){const b=c.length;b>0&&(a.groupCollapsed(`During precaching cleanup, ${b} cached request${b===1?" was":"s were"} deleted.`),aF("Deleted Cache Requests",c),a.groupEnd())}function L(c,b){if(b.length===0)return;a.groupCollapsed(c);for(const c of b)a.log(c);a.groupEnd()}function aU(d,e){const c=d.length,b=e.length;if(c||b){let f=`Precaching ${c} file${c===1?"":"s"}.`;b>0&&(f+=` ${b} file${b===1?" is":"s are"} already cached.`),a.groupCollapsed(f),L(`View newly precached URLs.`,d),L(`View previously precached URLs.`,e),a.groupEnd()}}g=class extends v{constructor(a={}){a.cacheName=k.getPrecacheName(a.cacheName),super(a),this._fallbackToNetwork=a.fallbackToNetwork!==!1,this.plugins.push(g.copyRedirectedCacheableResponsesPlugin)}async _handle(b,a){const c=await a.cacheMatch(b);return c?c:a.event&&a.event.type==="install"?await this._handleInstall(b,a):await this._handleFetch(b,a)}async _handleFetch(c,e){let f;const g=e.params||{};if(this._fallbackToNetwork){{!0&&a.warn(`The precached response for ${d(c.url)} in ${this.cacheName} was not found. Falling back to the network.`);const b=g.integrity,h=c.integrity,i=!h||h===b;if(f=await e.fetch(new Request(c,{integrity:h||b})),b&&i){this._useDefaultCacheabilityPluginIfNeeded();const b=await e.cachePut(c,f.clone());!0&&b&&a.log(`A response for ${d(c.url)} was used to "repair" the precache.`)}}}else throw new b("missing-precache-entry",{cacheName:this.cacheName,url:c.url});if(!0){const b=g.cacheKey||await e.getCacheKey(c,"read");a.groupCollapsed(`Precaching is responding to: `+d(c.url)),a.log(`Serving the precached url: ${d(b instanceof Request?b.url:b)}`),a.groupCollapsed(`View request details here.`),a.log(c),a.groupEnd(),a.groupCollapsed(`View response details here.`),a.log(f),a.groupEnd(),a.groupEnd()}return f}async _handleInstall(a,d){this._useDefaultCacheabilityPluginIfNeeded();const c=await d.fetch(a),e=await d.cachePut(a,c.clone());if(!e)throw new b("bad-precaching-response",{url:a.url,status:c.status});return c}_useDefaultCacheabilityPluginIfNeeded(){let a=null,b=0;for(const[d,c]of this.plugins.entries()){if(c===g.copyRedirectedCacheableResponsesPlugin)continue;c===g.defaultPrecacheCacheabilityPlugin&&(a=d),c.cacheWillUpdate&&b++}b===0?this.plugins.push(g.defaultPrecacheCacheabilityPlugin):b>1&&a!==null&&this.plugins.splice(a,1)}},g.defaultPrecacheCacheabilityPlugin={async cacheWillUpdate({response:a}){return!a||a.status>=400?null:a}},g.copyRedirectedCacheableResponsesPlugin={async cacheWillUpdate({response:a}){return a.redirected?await Z(a):a}},aK=class{constructor({cacheName:a,plugins:b=[],fallbackToNetwork:c=!0}={}){this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new g({cacheName:k.getPrecacheName(a),plugins:[...b,new aE({precacheController:this})],fallbackToNetwork:c}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(a){this.addToCacheList(a),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(e){!0&&c.isArray(e,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"addToCacheList",paramName:"entries"});const d=[];for(const c of e){typeof c=="string"?d.push(c):c&&c.revision===void 0&&d.push(c.url);const{cacheKey:f,url:g}=aC(c),h=typeof c!="string"&&c.revision?"reload":"default";if(this._urlsToCacheKeys.has(g)&&this._urlsToCacheKeys.get(g)!==f)throw new b("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(g),secondEntry:f});if(typeof c!="string"&&c.integrity){if(this._cacheKeysToIntegrities.has(f)&&this._cacheKeysToIntegrities.get(f)!==c.integrity)throw new b("add-to-cache-list-conflicting-integrities",{url:g});this._cacheKeysToIntegrities.set(f,c.integrity)}if(this._urlsToCacheKeys.set(g,f),this._urlsToCacheModes.set(g,h),d.length>0){const b=`Workbox is precaching URLs without revision info: ${d.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;a.warn(b)}}}install(a){return C(a,async()=>{const b=new aD;this.strategy.plugins.push(b);for(const[b,c]of this._urlsToCacheKeys){const d=this._cacheKeysToIntegrities.get(c),e=this._urlsToCacheModes.get(b),f=new Request(b,{integrity:d,cache:e,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:c},request:f,event:a}))}const{updatedURLs:c,notUpdatedURLs:d}=b;return!0&&aU(c,d),{updatedURLs:c,notUpdatedURLs:d}})}activate(a){return C(a,async()=>{const b=await self.caches.open(this.strategy.cacheName),c=await b.keys(),d=new Set(this._urlsToCacheKeys.values()),a=[];for(const e of c)d.has(e.url)||(await b.delete(e),a.push(e.url));return!0&&aG(a),{deletedURLs:a}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(a){const b=new URL(a,location.href);return this._urlsToCacheKeys.get(b.href)}getIntegrityForCacheKey(a){return this._cacheKeysToIntegrities.get(a)}async matchPrecache(a){const c=a instanceof Request?a.url:a,b=this.getCacheKeyForURL(c);if(b){const a=await self.caches.open(this.strategy.cacheName);return a.match(b)}}createHandlerBoundToURL(a){const c=this.getCacheKeyForURL(a);if(!c)throw new b("non-precached-url",{url:a});return b=>(b.request=new Request(a),b.params=Object.assign({cacheKey:c},b.params),this.strategy.handle(b))}},M=()=>(p||(p=new aK),p);function aN(a,b=[]){for(const c of[...a.searchParams.keys()])b.some(a=>a.test(c))&&a.searchParams.delete(c);return a}function*aO(g,{ignoreURLParametersMatching:e=[/^utm_/,/^fbclid$/],directoryIndex:c="index.html",cleanURLs:f=!0,urlManipulation:d}={}){const b=new URL(g,location.href);b.hash="",yield b.href;const a=aN(b,e);if(yield a.href,c&&a.pathname.endsWith("/")){const b=new URL(a.href);b.pathname+=c,yield b.href}if(f){const b=new URL(a.href);b.pathname+=".html",yield b.href}if(d){const a=d({url:b});for(const b of a)yield b.href}}aP=class extends j{constructor(b,c){const e=({request:e})=>{const f=b.getURLsToCacheKeys();for(const d of aO(e.url,c)){const a=f.get(d);if(a){const c=b.getIntegrityForCacheKey(a);return{cacheKey:a,integrity:c}}}!0&&a.debug(`Precaching did not find a match for `+d(e.url))};super(e,b.strategy)}};function aQ(a){const b=M(),c=new aP(b,a);A(c)}function aR(a){const b=M();b.precache(a)}function aS(a,b){aR(a),aQ(b)}self.__WB_DISABLE_DEV_LOGS=!0,t="the-handy-haversack",Y({prefix:t}),aw=O||[],aS([...aw.map(a=>({url:a,revision:null}))]),A(({request:a})=>a.mode==="navigate",new U({cacheName:`${t}-pages`,networkTimeoutSeconds:5,plugins:[new J({statuses:[200]})]})),A(({request:a})=>a.destination==="image",new S({cacheName:`${t}-images`,plugins:[new J({statuses:[200]}),new aA({maxEntries:250,maxAgeSeconds:60*60*24*30,purgeOnQuotaError:!0})]}))})()